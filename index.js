import { readFileSync, writeFileSync } from 'fs';
import camelCase from 'camel-case';
import utils from '@whook/http-router/dist/utils.js';

// adapted from openapi-sdk-js-builder
async function generateSDKFromOpenAPI(openAPIContent, sdkVersion) {
  const API = await utils.flattenOpenAPI(JSON.parse(openAPIContent));
  const operations = utils.getOpenAPIOperations(API);
  const content = `
// WARNING: This file is automatically generated
// do not change it in place it would be overridden
// by the next build
'use strict';

/**
 * ${API.info.description}
 * @module API
 * @version ${API.info.version}
 */
const API = {
  ${operations.map(({
    operationId
  }) => operationId).join(',\n  ')},
  host: '${API.servers[0].url}',
};

${operations.map(operation => {
    const {
      path,
      method,
      operationId,
      parameters,
      requestBody,
      security,
    } = operation;
    return `
    
/**
 * ${operation.summary}
 * @param {Object} parameters
 * The parameters to provide (destructured)${requestBody ? `
  @param body The request body
` : ''}${(parameters || []).filter(p => !['X-API-Version', 'X-SDK-Version', 'X-APP-Version'].includes(p.name)).map(parameter => `
 * @param {${parameter.schema ? parameter.schema.oneOf ? [...new Set(parameter.schema.oneOf.map(s => s.type))].join('|') : parameter.schema.type : parameter.type}} ${parameter.required ? `` : `[`}parameters.${camelCase(parameter.name)}${parameter.required ? `` : `]`}
 * ${parameter.description}`)}
 * @return {Object}
 * The HTTP response
${Object.keys(operation.responses).map(key => {
      let content = Object.values(operation.responses[key].content)[0];
      let data = content.examples ? content.examples : content.example || content.schema;
      return ` * @response ${key}\n${Object.entries(data).map(([k, v]) => ` * * ${k}: ${JSON.stringify(v)}`).join('\n')}\n`;
    }).join('')}
 */
function ${operationId}(${requestBody || parameters && parameters.length ? `{${requestBody ? `
      body,` : ''}${(parameters || []).filter(p => !['X-API-Version', 'X-SDK-Version'].includes(p.name)).map(parameter => {
      const variableName = camelCase(parameter.name);
      return `\n  ${variableName},`;
    }).join('')}} = {},` : ''} ${security ? "" + Object.keys(security[0])[0] + "," : ''} options) {
      
${(parameters || []).map(parameter => {
      if (parameter.required) {
        return `
  if( ${camelCase(parameter.name)} == null) {
    throw new Error('Missing required parameter : ${camelCase(parameter.name)}. Value : ' +  ${camelCase(parameter.name)});
  }
`;
      }
    }).join('')}

  let urlParts = [${path.split('/').filter(identity => identity).map(part => {
      const result = /^{(.*)}$/gi.exec(part);
      if (result) {
        return `
    ${camelCase(result[1])},`;
      }

      return `
    '${part}',`;
    }).join('')}
  ];
  let headers = {
    'Content-Type': 'application/json',
    'Accept-Version': '1.0'
  };

  if (options) {
    headers = Object.assign({}, headers, options);
  } 

  let data = ${requestBody ? `body;` : '{'}
   ${!requestBody ? '};' : ''} 

  ${(parameters || []).filter(p => 'query' === p.in).map(parameter => `
  if(${camelCase(parameter.name)} !== undefined) {
    data['${parameter.name}'] = ${camelCase(parameter.name)};
  }`).join('\n')}
  let fetchWrapper = new FetchWrapper(${security ? "" + Object.keys(security[0])[0] + "" : ''})
  return fetchWrapper.${method}('/'+urlParts.join('/'), headers, data)
}`;
  }).join('\n')}

class FetchWrapper {
  constructor(authkey) {
    this.authkey = authkey;
    /*if(this.authkey)
      this.protocol = "https://"
    else
      this.protocol = "http://"*/
    this.host = API.host;
  }
  get(url, headers,params) {
    let queryString = '';
    if (params) {
        // Convert the params object to a query string
        queryString = Object.keys(params).map(function(key) {
            return key + '=' + params[key];
        }).join('&');
        queryString = '?' + queryString;
    }
    if (this.authkey) {
      headers['Authorization'] = \`Bearer \${this.authkey}\`;
    }
    let requestOptions = {
        method: 'GET',
        headers: headers
    };
    /*this.protocol +*/
    return fetch( this.host + url + queryString, requestOptions).then(this.handleResponse);
  }

  post(url, headers, body) {
    if (this.authkey) {
      headers['Authorization'] = 'Bearer \${this.authkey}';
    }
    let requestOptions = {
        method: 'POST',
        headers: headers,
        body: JSON.stringify(body)
    };
    return fetch(this.protocol + url, requestOptions).then(handleResponse);
  }

  put(url, headers, body) {
    if (this.authkey) {
      headers['Authorization'] = 'Bearer \${this.authkey}';
    }
    let requestOptions = {
        method: 'PUT',
        headers: headers,
        body: JSON.stringify(body)
    };
    return fetch(this.protocol + url, requestOptions).then(handleResponse);    
  }

// prefixed with underscored because delete is a reserved word in javascript
  _delete(url, headers) {
    if (this.authkey) {
      headers['Authorization'] = 'Bearer \${this.authkey}';
    }
    let requestOptions = {
        method: 'DELETE',
        headers: headers
    };
    return fetch(this.protocol + url, requestOptions).then(handleResponse);
  }

// helper functions

  handleResponse(response) {
    return response.text().then(function(text) {
       let data = text && JSON.parse(text);
        
        if (!response.ok) {
            return Promise.reject({error: data.error, description: data.description});
        }

        return data;
    });
  }
}
//module.exports = API;
export default API;
`;
  return content;
}

async function generateAndWriteSDK() {
  const openAPIContents = readFileSync('openapi3_0.json', 'utf-8');
  const sdkContents = await generateSDKFromOpenAPI(openAPIContents);
  writeFileSync('sdk.js', sdkContents, 'utf-8');
}

generateAndWriteSDK().catch(console.error);